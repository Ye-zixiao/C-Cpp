#include<iostream>
#include<utility>
#include<memory>
using std::cout;
using std::endl;

class Val {
public:
	Val(int val) :
		pvalue(new int(val)) {}
	~Val() {
		if (pvalue)
			delete pvalue;
	}

	Val(Val&& item) ://1、此时被屏蔽 //4、此时被屏蔽
		pvalue(std::move(item.pvalue)) {
		std::cout << "Val(Val&&)" << endl;
		item.pvalue = nullptr;
	}

	Val(const Val& item) ://2、此时被屏蔽
		pvalue(new int(*item.pvalue)) {
		cout << "Val(const Val&)" << endl;
	}

private:
	int* pvalue = nullptr;
};

class Test {
public:
	Test(int val) :
		value(val) {}

	//3、此时default的显式要求构造移动构造函数是成功的
	Test(const Test&) = default;
	//Test(Test&&) = default;
	//Test(Test&&) = delete;

private:
	Val value;
};

int main(void)
{
	Test test(10), test_copy = std::move(test);	//1、此时使用的Test的合成拷贝构造函数
												//2、此时使用的Test的合成移动构造函数
												//3、此时显式要求合成Test的移动构造函数是成功的
												//4、此时显式要求合成Test的移动构造函数是失败的，故移动构造函数是删除的，但编译器会合成拷贝构造函数
	Test test_cpy = test;
}




/*
当我们不定义任何自定义版本的拷贝控制成员（拷贝构造、拷贝赋值、析构、移动构造、移动赋值）时，
1、数据成员类定义了移动操作、拷贝操作
			---->那么我们的类会合成相应的移动构造函数，此时拷贝构造函数是删除的，也就是说此时
				我们不能使用拷贝构造函数构造函数，只能要求以std::move的方式移动构造新的类对象
2、数据成员类定义了移动操作，但不定义拷贝操作
			---->那么我们的类会合成相应的移动构造函数，此时拷贝构造函数是删除的，结果也和上面相同的
3、数据成员类定义了拷贝操作，但没有定义移动操作
			---->那么我们的类不会被编译器合成移动构造函数，而是被删除，此时编译器会转而去合成相应的拷贝构造函数，
				此时无论我们是使用std::move（传递的是右值引用）构造新的对象，还是直接用=（传递的是左值）去创建新的对象
				都其实调用的是拷贝构造函数
4、数据成员类什么也没有定义拷贝控制成员
			---->一般我们接触的类（内置类型、string、stl容器）都是可移动的，不是很能想得到不能移动的。
				所以一般编译器会合成移动操作，此时拷贝构造是删除的，此时的结果跟（1）相同

当我们在类中要求编译器显式（=default）地合成移动操作
5、数据成员类定义了拷贝操作、移动操作
			---->那么我们的类会合成移动操作，此时拷贝操作是删除的，只能使用std::move的方式创建新的
				对象
6、数据成员定义了移动操作，但没有定义拷贝操作
			---->那么我们的类会合成移动操作，但是拷贝操作会被删除，只能使用std::move的方式创建新的类对象
7、数据成员定义了拷贝操作，但没有定义移动操作
			---->那么我们的类会删除移动操作，但可以合成拷贝操作，我们无论是使用std::move（传入右值引用）的方式还是
				=(传入左值)都其实在调用该类由编译器合成的拷贝操作
8、数据成员什么也没有定义
			---->一般而言会合成移动操作，而拷贝操作在移动操作合成之后会被删除。当然我说的是数据成员的类型是一个比较
				基础的类型，比如string、stl容器、内置类型等等，目前为止还没有特别深入接触没有移动操作的类，或在之前使用中
				没有在意

				某个或某些操作被删除只不过是代表这些操作不能使用，不代表其他操作不能使用，使用其他操作不会报错，
			但如果硬要使用这些被删除的操作就会报错
*/
